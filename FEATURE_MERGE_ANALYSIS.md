# SAPAS vs InStock åŠŸèƒ½å¯¹æ¯”ä¸åˆå¹¶å»ºè®®

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

æœ¬æ–‡æ¡£å¯¹æ¯”åˆ†æäº† SAPASï¼ˆStockInsightï¼‰ä¸ [InStock](https://github.com/myhhub/stock) ä¸¤ä¸ªè‚¡ç¥¨åˆ†æå¹³å°çš„åŠŸèƒ½ï¼Œè¯†åˆ«å¯å€Ÿé‰´çš„åŠŸèƒ½ï¼Œå¹¶åˆ¶å®šè¯¦ç»†çš„åˆå¹¶å®æ–½è®¡åˆ’ã€‚

**åˆ†ææ—¥æœŸ**: 2026-01-23
**InStock ä»“åº“**: https://github.com/myhhub/stock

---

## ğŸ“ˆ é¡¹ç›®åŠŸèƒ½å¯¹æ¯”

### SAPAS (StockInsight) ç°æœ‰åŠŸèƒ½

| æ¨¡å— | åŠŸèƒ½ | çŠ¶æ€ | æŠ€æœ¯æ ˆ |
|------|------|------|--------|
| **æ•°æ®è·å–** | AKShare API é›†æˆ | âœ… å·²å®ç° | Python + AKShare |
| **åŸºç¡€æ•°æ®** | è‚¡ç¥¨åˆ—è¡¨ã€æ—¥Kçº¿ã€åˆ†æ—¶ | âœ… å·²å®ç° | FastAPI + PostgreSQL |
| **æŠ€æœ¯æŒ‡æ ‡** | MA, MACD, KDJ, RSI, BOLL ç­‰ | âœ… å·²å®ç° | Pandas-TA |
| **å›æµ‹ç³»ç»Ÿ** | åŸºäº Backtrader çš„ç­–ç•¥å›æµ‹ | âœ… å·²å®ç° | Backtrader + Matplotlib |
| **é€‰è‚¡å™¨** | æŠ€æœ¯æŒ‡æ ‡é€‰è‚¡ | âœ… å·²å®ç° | Pandas + NumPy |
| **å‘Šè­¦ç³»ç»Ÿ** | ä»·æ ¼å’ŒæŠ€æœ¯æŒ‡æ ‡å‘Šè­¦ | âœ… å·²å®ç° | APScheduler |
| **è‡ªé€‰è‚¡** | è‡ªé€‰è‚¡ç®¡ç†å’Œç›‘æ§ | âœ… å·²å®ç° | PostgreSQL |
| **èµ„é‡‘æµå‘** | ä¸ªè‚¡èµ„é‡‘æµå‘åˆ†æ | âœ… å·²å®ç° | AKShare API |
| **é›†åˆç«ä»·** | é›†åˆç«ä»·æ•°æ®åˆ†æ | âœ… å·²å®ç° | ä¸œæ–¹è´¢å¯Œç½‘ API |
| **WebSocket** | å®æ—¶è¡Œæƒ…æ¨é€ | âœ… å·²å®ç° | WebSocket + Redis |
| **ç”¨æˆ·ç³»ç»Ÿ** | ç™»å½•ã€æƒé™ç®¡ç† | âœ… å·²å®ç° | JWT + Pydantic |
| **å‰ç«¯ç•Œé¢** | Vue 3 + Element Plus | âœ… å·²å®ç° | Vue 3 + TypeScript |

### InStock (myhhub/stock) æ ¸å¿ƒåŠŸèƒ½

| æ¨¡å— | åŠŸèƒ½ | ä»·å€¼ | ä¼˜å…ˆçº§ |
|------|------|------|--------|
| **ç»¼åˆé€‰è‚¡** | 200+ ä¿¡æ¯ç»´åº¦çš„å¤šç»´åº¦é€‰è‚¡ | â­â­â­â­â­ | ğŸ”´ é«˜ |
| **Kçº¿å½¢æ€è¯†åˆ«** | 61ç§ Kçº¿å½¢æ€è‡ªåŠ¨è¯†åˆ« | â­â­â­â­â­ | ğŸ”´ é«˜ |
| **ç­¹ç åˆ†æ** | CYQ ç­¹ç åˆ†å¸ƒåˆ†æ | â­â­â­â­â­ | ğŸ”´ é«˜ |
| **é¾™è™æ¦œ** | æ¯æ—¥é¾™è™æ¦œæ•°æ® | â­â­â­â­ | ğŸŸ¡ ä¸­ |
| **èµ„é‡‘æµå‘** | å¤§å•èµ„é‡‘æµå‘åˆ†æï¼ˆæ›´ç»†è‡´ï¼‰ | â­â­â­â­ | ğŸŸ¡ ä¸­ |
| **è·Œåœåˆ†æ** | è·ŒåœåŸå› åˆ†æ | â­â­â­â­ | ğŸŸ¡ ä¸­ |
| **é‡åŒ–ç­–ç•¥** | 10+ å†…ç½®äº¤æ˜“ç­–ç•¥ | â­â­â­â­â­ | ğŸŸ¢ ä½ |
| **è‡ªåŠ¨åŒ–äº¤æ˜“** | IPO ç”³è´­ã€ç­–ç•¥è‡ªåŠ¨æ‰§è¡Œ | â­â­â­â­â­ | ğŸŸ¢ ä½ |
| **å¤§å•åˆ†æ** | ç»†åˆ†å¤§å•ç±»å‹åˆ†æ | â­â­â­â­ | ğŸŸ¢ ä½ |
| **ETF æ•°æ®** | ETF è¡Œæƒ…ã€æŒä»“ã€å‡€å€¼ | â­â­â­â­ | ğŸŸ¢ ä½ |

---

## ğŸ¯ æ¨èåˆå¹¶çš„åŠŸèƒ½ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰

### ğŸ”´ é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å®æ–½ï¼‰

#### 1. Kçº¿å½¢æ€è¯†åˆ« (61ç§)

**åŠŸèƒ½æè¿°**ï¼šè‡ªåŠ¨è¯†åˆ« K çº¿å›¾ä¸­çš„æŠ€æœ¯å½¢æ€ï¼Œå¦‚ä¸‰åªä¹Œé¸¦ã€æ—©æ™¨ä¹‹æ˜Ÿã€é”¤å­çº¿ç­‰ï¼Œæä¾›ä¹°å–ä¿¡å·

**å•†ä¸šä»·å€¼**ï¼š
- è¾…åŠ©äº¤æ˜“å†³ç­–ï¼Œæä¾›å½¢æ€ä¹°å…¥/å–å‡ºä¿¡å·
- ç»“åˆç°æœ‰æŠ€æœ¯æŒ‡æ ‡ï¼Œæå‡ä¿¡å·å‡†ç¡®ç‡
- æä¾›æ›´ç›´è§‚çš„æŠ€æœ¯åˆ†æ

**æŠ€æœ¯å®ç°å¤æ‚åº¦**ï¼šä¸­é«˜

**å…³é”®å½¢æ€åˆ—è¡¨**ï¼ˆä¼˜å…ˆå®ç°å‰10ä¸ªï¼‰ï¼š

| åºå· | å½¢æ€åç§° | ç±»å‹ | ä¿¡å· |
|------|---------|------|------|
| 1 | ä¸‰åªä¹Œé¸¦ | çœ‹è·Œ | sell |
| 2 | æ—©æ™¨ä¹‹æ˜Ÿ | çœ‹æ¶¨ | buy |
| 3 | é»„æ˜ä¹‹æ˜Ÿ | çœ‹è·Œ | sell |
| 4 | å°„å‡»ä¹‹æ˜Ÿ | åè½¬ | ä¸­æ€§ |
| 5 | é”¤å­çº¿ | åè½¬ | ä¸­æ€§ |
| 6 | æµæ˜Ÿçº¿ | åè½¬ | ä¸­æ€§ |
| 7 | å­•å©´ | åè½¬ | ä¸­æ€§ |
| 8 | åå­• | çœ‹æ¶¨ | buy |
| 9 | çº¢ä¸‰å…µ | çœ‹æ¶¨ | buy |
| 10 | ä¸‰ç™½å…µ | çœ‹æ¶¨ | buy |

**æ•°æ®æ¨¡å‹è®¾è®¡**ï¼š

```python
# src/models/pattern.py
from sqlalchemy import Column, BigInteger, String, Date, Integer, Text, JSON
from sqlalchemy.orm import Mapped

class StockPattern(Base, TimestampMixin):
    """Kçº¿å½¢æ€æ•°æ®è¡¨"""
    __tablename__ = "stock_patterns"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    code: Mapped[str] = mapped_column(String(10), nullable=False, index=True)
    trade_date: Mapped[date] = Column(Date, nullable=False, index=True)
    pattern_type: Mapped[str] = mapped_column(String(50), nullable=False)  # å½¢æ€ç±»å‹
    pattern_name: Mapped[str] = mapped_column(String(100), nullable=False)  # å½¢æ€åç§°
    signal: Mapped[str] = mapped_column(String(20), nullable=False)  # buy/sell/neutral
    reliability: Mapped[int] = mapped_column(Integer, nullable=False, default=50)  # å¯é æ€§è¯„åˆ† 0-100
    pattern_data: Mapped[dict] = mapped_column(JSON, nullable=True)  # å½¢æ€è¯¦ç»†æ•°æ®
    detected_at: Mapped[datetime] = Column(DateTime, nullable=False, default=datetime.now)

    # å¤åˆç´¢å¼•
    __table_args__ = (
        Index("idx_pattern_code_date", "code", "trade_date"),
        Index("idx_pattern_signal", "pattern_type", "signal"),
    )
```

**API ç«¯ç‚¹è®¾è®¡**ï¼š

```python
# src/api/patterns.py

from fastapi import APIRouter, Depends, Query
from sqlalchemy import select, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession

router = APIRouter(prefix="/patterns", tags=["patterns"])

@router.get("/stock/{code}/patterns", response_model=List[PatternResponse])
async def get_stock_patterns(
    code: str,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    signal: Optional[str] = Query(None, description="è¿‡æ»¤ä¿¡å·ç±»å‹: buy/sell/neutral"),
    db: AsyncSession = Depends(get_db)
):
    """
    è·å–æŒ‡å®šè‚¡ç¥¨çš„Kçº¿å½¢æ€æ•°æ®

    å‚æ•°:
        code: è‚¡ç¥¨ä»£ç 
        start_date: å¼€å§‹æ—¥æœŸ
        end_date: ç»“æŸæ—¥æœŸ
        signal: ä¿¡å·ç±»å‹è¿‡æ»¤
    """
    query = select(StockPattern).where(StockPattern.code == code)

    if start_date:
        query = query.where(StockPattern.trade_date >= start_date)
    if end_date:
        query = query.where(StockPattern.trade_date <= end_date)
    if signal:
        query = query.where(StockPattern.signal == signal)

    query = query.order_by(StockPattern.trade_date.desc())

    result = await db.execute(query)
    return result.scalars().all()

@router.get("/patterns/latest", response_model=PatternSummary)
async def get_latest_patterns(
    signal: Optional[str] = Query(None, description="è¿‡æ»¤ä¿¡å·ç±»å‹"),
    limit: int = Query(20, ge=1, le=100),
    db: AsyncSession = Depends(get_db)
):
    """è·å–æœ€æ–°çš„å½¢æ€ä¿¡å·"""
    query = select(StockPattern, StockBasics.name).join(
        StockBasics, StockPattern.code == StockBasics.code
    ).order_by(StockPattern.trade_date.desc(), StockPattern.detected_at.desc())

    if signal:
        query = query.where(StockPattern.signal == signal)

    query = query.limit(limit)

    result = await db.execute(query)
    return result.all()
```

**å‰ç«¯å±•ç¤ºç»„ä»¶**ï¼š

```vue
<!-- web/src/components/PatternIndicator.vue -->
<template>
  <div class="pattern-indicator">
    <el-tag
      v-if="pattern"
      :type="getTagType(pattern.signal)"
      size="small"
      effect="dark"
    >
      {{ pattern.pattern_name }}
    </el-tag>
    <span class="reliability">{{ pattern.reliability }}%</span>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import type { PatternData } from '@/api/patterns'

const props = defineProps<{
  pattern: PatternData | null
}>()

const getTagType = (signal: string) => {
  if (signal === 'buy') return 'success'
  if (signal === 'sell') return 'danger'
  return 'info'
}
</script>
```

**å½¢æ€è¯†åˆ«æ ¸å¿ƒé€»è¾‘**ï¼š

```python
# src/services/pattern_recognizer.py
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Callable

class PatternRecognizer:
    """Kçº¿å½¢æ€è¯†åˆ«å™¨"""

    # å½¢æ€è¯†åˆ«å‡½æ•°æ˜ å°„
    PATTERNS: Dict[str, Callable] = {}

    def __init__(self):
        self._init_patterns()

    def _init_patterns(self):
        """åˆå§‹åŒ–æ‰€æœ‰å½¢æ€è¯†åˆ«å‡½æ•°"""
        self.PATTERNS = {
            'two_crows': self.check_two_crows,
            'three_crows': self.check_three_crows,
            'three_white_soldiers': self.check_three_white_soldiers,
            'morning_star': self.check_morning_star,
            'evening_star': self.check_evening_star,
            'doji': self.check_doji,
            'hammer': self.check_hammer,
            'inverted_hammer': self.check_inverted_hammer,
            'engulfing': self.check_engulfing,
            'harami': self.check_harami,
            'piercing': self.check_piercing,
            # ... æ›´å¤šå½¢æ€
        }

    def recognize(
        self,
        df: pd.DataFrame,
        patterns: Optional[List[str]] = None
    ) -> pd.DataFrame:
        """
        è¯†åˆ«Kçº¿æ•°æ®ä¸­çš„å½¢æ€

        å‚æ•°:
            df: Kçº¿æ•°æ®ï¼Œéœ€åŒ…å« open, close, high, low, volume
            patterns: è¦è¯†åˆ«çš„å½¢æ€åˆ—è¡¨ï¼ŒNoneè¡¨ç¤ºè¯†åˆ«æ‰€æœ‰
        """
        if patterns is None:
            patterns = list(self.PATTERNS.keys())

        results = []

        for pattern_name in patterns:
            if pattern_name in self.PATTERNS:
                pattern_func = self.PATTERNS[pattern_name]
                signals = pattern_func(df)
                results.append(signals)

        # åˆå¹¶æ‰€æœ‰ä¿¡å·
        all_signals = pd.concat(results, axis=1)
        return all_signals

    def check_two_crows(self, df: pd.DataFrame) -> pd.Series:
        """
        ä¸‰åªä¹Œé¸¦å½¢æ€
        æ¡ä»¶:
        1. è¿ç»­ä¸‰æ ¹é˜´çº¿
        2. æ¯æ—¥æ”¶ç›˜ä»·ä½äºå‰ä¸€æ—¥
        3. æ¯æ—¥æ”¶ç›˜ä»·æ¥è¿‘å½“æ—¥æœ€ä½ä»·
        4. å®ä½“éƒ¨åˆ†è¾ƒå°
        """
        # å®ç°é€»è¾‘
        pass

    def check_morning_star(self, df: pd.DataFrame) -> pd.Series:
        """
        æ—©æ™¨ä¹‹æ˜Ÿå½¢æ€
        æ¡ä»¶:
        1. ç¬¬ä¸€å¤©é˜´çº¿ï¼Œç¬¬äºŒå¤©å°å®ä½“ï¼ˆåå­—æ˜Ÿï¼‰ï¼Œç¬¬ä¸‰å¤©é˜³çº¿
        2. ç¬¬ä¸‰å¤©æ”¶ç›˜ä»·é«˜äºç¬¬ä¸€å¤©å®ä½“ä¸­éƒ¨
        3. æˆäº¤é‡èç¼©åæ”¾å¤§
        """
        # å®ç°é€»è¾‘
        pass
```

**æ•°æ®åŒæ­¥æ–¹æ¡ˆ**ï¼š

```python
# src/services/sync_patterns.py
from src.services.data_sync import data_sync_service

class PatternSyncService:
    """å½¢æ€æ•°æ®åŒæ­¥æœåŠ¡"""

    async def sync_patterns_for_stock(
        self,
        session: AsyncSession,
        code: str,
        start_date: date,
        end_date: date
    ):
        """
        åŒæ­¥æŒ‡å®šè‚¡ç¥¨çš„Kçº¿å½¢æ€æ•°æ®
        """
        # 1. è·å–Kçº¿æ•°æ®
        kline_data = await self._get_kline_data(session, code, start_date, end_date)

        # 2. è½¬æ¢ä¸ºDataFrame
        df = pd.DataFrame([{
            'trade_date': k.trade_date,
            'open': float(k.open_price) if k.open_price else None,
            'close': float(k.close_price) if k.close_price else None,
            'high': float(k.high_price) if k.high_price else None,
            'low': float(k.low_price) if k.low_price else None,
            'volume': k.volume,
        } for k in kline_data])

        # 3. è¯†åˆ«å½¢æ€
        recognizer = PatternRecognizer()
        patterns = recognizer.recognize(df)

        # 4. ä¿å­˜åˆ°æ•°æ®åº“
        for trade_date, pattern_signals in patterns.items():
            for pattern_name, signal in pattern_signals.items():
                if signal != 'neutral':
                    # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                    existing = await session.execute(
                        select(StockPattern).where(
                            and_(
                                StockPattern.code == code,
                                StockPattern.trade_date == trade_date,
                                StockPattern.pattern_name == pattern_name
                            )
                        ).exists()
                    )

                    if not existing.scalars():
                        pattern = StockPattern(
                            code=code,
                            trade_date=trade_date,
                            pattern_type=pattern_name,
                            pattern_name=pattern_name,
                            signal=signal,
                            reliability=70
                        )
                        session.add(pattern)

        await session.commit()
```

#### 2. ç­¹ç åˆ†å¸ƒåˆ†æ (CYQ)

**åŠŸèƒ½æè¿°**ï¼šåŸºäºæˆäº¤é‡å’Œä»·æ ¼è®¡ç®—ç­¹ç åˆ†å¸ƒï¼Œè¯†åˆ«ä¸»åŠ›æˆæœ¬åŒºå’Œæ”¯æ’‘/é˜»åŠ›ä½

**å•†ä¸šä»·å€¼**ï¼š
- è¯†åˆ«ä¸»åŠ›æˆæœ¬åŒº
- é¢„æµ‹è‚¡ä»·æ”¯æ’‘ä½å’Œå‹åŠ›ä½
- è¾…åŠ©åˆ¤æ–­ä¹°å–æ—¶æœº
- å¯è§†åŒ–ç­¹ç åˆ†å¸ƒå›¾

**æŠ€æœ¯å®ç°å¤æ‚åº¦**ï¼šä¸­

**æ•°æ®æ¨¡å‹è®¾è®¡**ï¼š

```python
# src/models/cyq.py
from sqlalchemy import Column, BigInteger, String, Date, Decimal, Integer, JSON

class StockCYQ(Base, TimestampMixin):
    """ç­¹ç åˆ†å¸ƒæ•°æ®è¡¨"""
    __tablename__ = "stock_cyq"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    code: Mapped[str] = mapped_column(String(10), nullable=False, index=True)
    trade_date: Mapped[date] = Column(Date, nullable=False, index=True)
    price_level: Mapped[Decimal] = Column(Decimal(12, 4), nullable=False)  # ä»·æ ¼åŒºé—´
    volume: Mapped[bigint] = Column(BigInteger, nullable=False)  # æˆäº¤é‡
    amount: Mapped[Decimal] = Column(Decimal(18, 4))  # æˆäº¤é¢
    percentage: Mapped[Decimal] = Column(Decimal(10, 4))  # å æ¯”
    avg_cost: Mapped[Decimal] = Column(Decimal(12, 4))  # å¹³å‡æˆæœ¬

    # å¤åˆç´¢å¼•
    __table_args__ = (
        Index("idx_cyq_code_date", "code", "trade_date"),
        Index("idx_cyq_date", "trade_date"),
    )
```

**æ ¸å¿ƒè®¡ç®—é€»è¾‘**ï¼š

```python
# src/services/cyq_analyzer.py
import pandas as pd
import numpy as np
from typing import List, Tuple, Dict

class CYQAnalyzer:
    """ç­¹ç åˆ†å¸ƒåˆ†æå™¨"""

    def __init__(self, price_bins: int = 100):
        """
        åˆå§‹åŒ–

        å‚æ•°:
            price_bins: ä»·æ ¼åŒºé—´æ•°é‡
        """
        self.price_bins = price_bins

    def calculate_distribution(
        self,
        kline_data: pd.DataFrame
    ) -> Tuple[pd.DataFrame, Dict]:
        """
        è®¡ç®—ç­¹ç åˆ†å¸ƒ

        å‚æ•°:
            kline_data: Kçº¿æ•°æ®ï¼Œéœ€åŒ…å« close, volume, amount

        è¿”å›:
            (åˆ†å¸ƒDataFrame, ç»Ÿè®¡ä¿¡æ¯Dict)
        """
        # 1. åˆ›å»ºä»·æ ¼åŒºé—´
        min_price = kline_data['close'].min()
        max_price = kline_data['close'].max()
        bin_size = (max_price - min_price) / self.price_bins

        # 2. ç»Ÿè®¡æ¯ä¸ªåŒºé—´çš„æˆäº¤é‡
        distribution = {}
        total_volume = 0
        total_amount = 0

        for _, row in kline_data.iterrows():
            close_price = row['close']
            volume = row['volume']
            amount = row.get('amount', 0)

            # ç¡®å®šä»·æ ¼åŒºé—´
            bin_key = int((close_price - min_price) / bin_size) * bin_size + min_price

            if bin_key not in distribution:
                distribution[bin_key] = {
                    'volume': 0,
                    'amount': 0,
                    'count': 0
                }

            distribution[bin_key]['volume'] += volume
            distribution[bin_key]['amount'] += amount
            distribution[bin_key]['count'] += 1
            total_volume += volume
            total_amount += amount

        # 3. è®¡ç®—å æ¯”
        cyq_data = []
        for price_level in sorted(distribution.keys()):
            item = distribution[price_level]
            cyq_data.append({
                'price_level': price_level,
                'volume': item['volume'],
                'amount': item['amount'],
                'count': item['count'],
                'volume_ratio': (item['volume'] / total_volume * 100) if total_volume > 0 else 0,
                'amount_ratio': (item['amount'] / total_amount * 100) if total_amount > 0 else 0,
                'avg_cost': item['amount'] / item['volume'] if item['volume'] > 0 else 0
            })

        return pd.DataFrame(cyq_data), {
            'total_volume': total_volume,
            'total_amount': total_amount,
            'price_range': (min_price, max_price),
            'support_level': self._find_support_level(cyq_data),
            'resistance_level': self._find_resistance_level(cyq_data)
        }

    def _find_support_level(self, cyq_data: pd.DataFrame) -> float:
        """æ‰¾åˆ°æ”¯æ’‘ä½ï¼ˆç­¹ç å¯†é›†åŒºï¼‰"""
        if cyq_data.empty:
            return 0
        # æ‰¾åˆ°æˆäº¤é‡æœ€å¤§çš„åŒºé—´
        max_vol_idx = cyq_data['volume'].idxmax()
        return cyq_data.loc[max_vol_idx, 'price_level']

    def _find_resistance_level(self, cyq_data: pd.DataFrame) -> float:
        """æ‰¾åˆ°é˜»åŠ›ä½ï¼ˆä¸Šæ–¹ç­¹ç å¯†é›†åŒºï¼‰"""
        # æ‰¾åˆ°ä¸Šæ–¹ç­¹ç é›†ä¸­çš„åŒºåŸŸ
        if cyq_data.empty:
            return 0

        mid_index = len(cyq_data) // 2
        upper_half = cyq_data.iloc[:mid_index]
        if upper_half.empty:
            return 0

        max_vol_idx = upper_half['volume'].idxmax()
        return upper_half.loc[max_vol_idx, 'price_level']

    def get_profit_ratio(
        self,
        code: str,
        current_price: float,
        session: AsyncSession
    ) -> Dict[str, float]:
        """
        è®¡ç®—ç›ˆåˆ©æ¯”ä¾‹

        å‚æ•°:
            code: è‚¡ç¥¨ä»£ç 
            current_price: å½“å‰ä»·æ ¼
            session: æ•°æ®åº“ä¼šè¯

        è¿”å›:
            ç›ˆåˆ©æ¯”ä¾‹å’ŒäºæŸæ¯”ä¾‹
        """
        # è·å–æœ€è¿‘çš„ç­¹ç åˆ†å¸ƒ
        # è®¡ç®—æœ‰å¤šå°‘ç­¹ç ç›ˆåˆ©/äºæŸ
        # è¿”å›ç»Ÿè®¡ä¿¡æ¯
        pass
```

#### 3. é¾™è™æ¦œæ•°æ®

**åŠŸèƒ½æè¿°**ï¼šæ¯æ—¥é¾™è™æ¦œæ•°æ®è·å–ã€åˆ†æå’Œå†å²ç»Ÿè®¡

**å•†ä¸šä»·å€¼**ï¼š
- äº†è§£å¸‚åœºçƒ­ç‚¹
- è·Ÿè¸ªæ¸¸èµ„åŠ¨å‘
- å‘ç°æ½œåœ¨é¾™å¤´è‚¡
- åˆ†æè¥ä¸šéƒ¨å¸­ä½åŠ¨å‘

**æ•°æ®æ¥æº**ï¼š
- ä¸œæ–¹è´¢å¯Œç½‘é¾™è™æ¦œï¼ˆå·²æœ‰ APIï¼‰
- åŒèŠ±é¡ºé¾™è™æ¦œ

**æ•°æ®æ¨¡å‹è®¾è®¡**ï¼š

```python
# src/models/dragon_tiger.py
from sqlalchemy import Column, BigInteger, String, Date, Decimal, Text, Boolean

class DragonTigerList(Base, TimestampMixin):
    """é¾™è™æ¦œæ•°æ®è¡¨"""
    __tablename__ = "dragon_tiger_lists"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    trade_date: Mapped[date] = Column(Date, nullable=False, index=True)
    code: Mapped[str] = mapped_column(String(10), nullable=False)
    name: Mapped[str] = mapped_column(String(50))
    reason: Mapped[str] = Column(Text)  # ä¸Šæ¦œç†ç”±
    net_buy: Mapped[Decimal] = Column(Decimal(18, 4))  # å‡€ä¹°å…¥(å…ƒ)
    net_buy_ratio: Mapped[Decimal] = Column(Decimal(10, 4))  # å‡€ä¹°å…¥ç‡
    total_buy: Mapped[Decimal] = Column(Decimal(18, 4))  # æ€»ä¹°å…¥(å…ƒ)
    total_sell: Mapped[Decimal] = Column(Decimal(18, 4))  # æ€»å–å‡º(å…ƒ)
    institution_buy: Mapped[Decimal] = Column(Decimal(18, 4))  # æœºæ„ä¹°å…¥(å…ƒ)
    institution_sell: Mapped[Decimal] = Column(Decimal(18, 4))  # æœºæ„å–å‡º(å…ƒ)
    retail_buy: Mapped[Decimal] = Column(Decimal(18, 4))  # æ•£æˆ·ä¹°å…¥(å…ƒ)
    retail_sell: Mapped[Decimal] = Column(Decimal(18, 4))  # æ•£æˆ·å–å‡º(å…ƒ)
    institution_buy_ratio: Mapped[Decimal] = Column(Decimal(10, 4))  # æœºæ„ä¹°å…¥æ¯”ä¾‹
   å¸­ä½å·: Mapped[str] = mapped_column(String(20))  # è¥ä¸šéƒ¨å¸­ä½
    å¸­ä½å: Mapped[str] = mapped_column(String(50))  # è¥ä¸šéƒ¨åç§°
   ä¸Šæ¦œæ¬¡æ•°: Mapped[int] = Column(Integer)  # è¿‘æœŸä¸Šæ¦œæ¬¡æ•°

    # å¤åˆç´¢å¼•
    __table_args__ = (
        Index("idx_dragon_date_code", "trade_date", "code"),
        Index("idx_dragon_date_net_buy", "trade_date", "net_buy", order_by="net_buy", op="DESC"),
        Index("idx_dragon_rank", "trade_date", "net_buy"),
    )
```

**API ç«¯ç‚¹è®¾è®¡**ï¼š

```python
# src/api/dragon_tiger.py

from fastapi import APIRouter, Depends, Query
from sqlalchemy import select, desc, func
from sqlalchemy.ext.asyncio import AsyncSession

router = APIRouter(prefix="/dragon-tiger", tags=["dragon-tiger"])

@router.get("/lists", response_model=DragonTigerResponse)
async def get_dragon_tiger_lists(
    trade_date: Optional[str] = Query(None, description="äº¤æ˜“æ—¥æœŸ YYYY-MM-DD"),
    limit: int = Query(50, ge=1, le=100),
    db: AsyncSession = Depends(get_db)
):
    """
    è·å–é¾™è™æ¦œæ•°æ®

    å‚æ•°:
        trade_date: äº¤æ˜“æ—¥æœŸï¼Œé»˜è®¤ä¸ºæœ€è¿‘ä¸€å¤©
        limit: è¿”å›æ¡æ•°
    """
    if not trade_date:
        # æŸ¥è¯¢æœ€è¿‘æ—¥æœŸçš„æ•°æ®
        result = await db.execute(
            select(DragonTigerList.trade_date)
            .order_by(desc(DragonTigerList.trade_date))
            .limit(1)
        )
        trade_date = result.scalar()
        if not trade_date:
            return DragonTigerResponse(
                trade_date="",
                total_count=0,
                data=[]
            )

    # æŸ¥è¯¢æŒ‡å®šæ—¥æœŸçš„é¾™è™æ¦œ
    query = select(DragonTigerList, StockBasics.name).join(
        StockBasics, DragonTigerList.code == StockBasics.code
    ).where(DragonTigerList.trade_date == trade_date)

    query = query.order_by(desc(DragonTigerList.net_buy))

    if limit:
        query = query.limit(limit)

    result = await db.execute(query)
    rows = result.all()

    # è¿”å›æ•°æ®
    total_count = len(rows)
    data = [
        DragonTigerItem(
            code=item[0].code,
            name=item[1],
            reason=item[0].reason,
            net_buy=float(item[0].net_buy) if item[0].net_buy else None,
            net_buy_ratio=float(item[0].net_buy_ratio) if item[0].net_buy_ratio else None,
            total_buy=float(item[0].total_buy) if item[0].total_buy else None,
            institution_buy=float(item[0].institution_buy) if item[0].institution_buy else None,
            institution_buy_ratio=float(item[0].institution_buy_ratio) if item[0].institution_buy_ratio else None,
            trading_volume=int(item[0].retail_buy + item[0].retail_sell),
            ranking=row[2] + 1 if row[2] else None  # æ’å
        )
        for row in rows
    ]

    return DragonTigerResponse(
        trade_date=trade_date,
        total_count=total_count,
        data=data
    )

@router.get("/stats/{trade_date_str}")
async def get_dragon_tiger_stats(
    trade_date_str: str,
    db: AsyncSession = Depends(get_db)
):
    """è·å–é¾™è™æ¦œç»Ÿè®¡æ•°æ®"""
    # å®ç°ç»Ÿè®¡æ•°æ®
    pass
```

---

### ğŸŸ¡ ä¸­ä¼˜å…ˆçº§ï¼ˆè¿‘æœŸå®æ–½ï¼‰

#### 4. è·Œåœåˆ†æ

**åŠŸèƒ½æè¿°**ï¼šåˆ†æè·Œåœè‚¡ç¥¨çš„åŸå› ï¼Œæä¾›åˆ†ç±»å’Œå†å²ç»Ÿè®¡

**åˆ†ç±»ç»´åº¦**ï¼š
- æŠ€æœ¯æ€§è·Œåœï¼ˆé«˜ä½ã€æ”¾é‡ã€ç ´ä½ï¼‰
- æ¶ˆæ¯é¢è·Œåœï¼ˆåˆ©ç©ºï¼‰
- å¸‚åœºæ€§è·Œåœï¼ˆç³»ç»Ÿæ€§é£é™©ï¼‰
- è¿ç»­è·Œåœ

**æ•°æ®æ¨¡å‹è®¾è®¡**ï¼š

```python
# src/models/limit_down.py
class LimitDown(Base, TimestampMixin):
    """è·Œåœåˆ†æè¡¨"""
    __tablename__ = "limit_downs"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    code: Mapped[str] = mapped_column(String(10))
    name: Mapped[str] = mapped_column(String(50))
    trade_date: Mapped[date] = Column(Date)
    limit_time: Mapped[str] = Column(String(10))  # è·Œåœæ—¶é—´
    reason: Mapped[str] = Column(String(200))  # è·ŒåœåŸå› 
    reason_type: Mapped[str] = Column(String(50))  # åŸå› ç±»å‹
    open_price: Mapped[Optional[Decimal]] = Column(Decimal(12, 4))
    close_price: Mapped[Optional[Decimal]] = Column(Decimal(12, 4))
    fall_pct: Mapped[Optional[Decimal]] = Column(Decimal(10, 4))
    volume: Mapped[Optional[BigInteger]] = Column(BigInteger)
    amount: Mapped[Optional[Decimal]] = Column(Decimal(18, 4))
```

#### 5. å¤§å•èµ„é‡‘æµå‘ï¼ˆç»†åŒ–ï¼‰

**å·²æœ‰åŸºç¡€**ï¼šå·²æœ‰ä¸ªè‚¡èµ„é‡‘æµå‘åŠŸèƒ½

**æ”¹è¿›ç‚¹**ï¼š
- å¤§å•ç±»å‹ç»†åˆ†ï¼šè¶…å¤§å•(>500ä¸‡)ã€å¤§å•(100-500ä¸‡)ã€ä¸­å•(20-100ä¸‡)ã€å°å•(<20ä¸‡)
- å¤§å•å‡€æµå…¥æ’å
- å®æ—¶å¤§å•ç›‘æ§
- å¤§å•æˆäº¤æ˜ç»†

**æ•°æ®æ¨¡å‹æ‰©å±•**ï¼š

```sql
-- åœ¨ç°æœ‰èµ„é‡‘æµå‘è¡¨åŸºç¡€ä¸Šï¼Œæ·»åŠ å¤§å•æ˜ç»†è¡¨
CREATE TABLE trade_details (
    id BIGSERIAL PRIMARY KEY,
    code VARCHAR(10),
    trade_date DATE,
    trade_time TIME,
    direction VARCHAR(10),  -- buy/sell
    order_type VARCHAR(20),  -- large_order/super_large_order/medium_order/small_order
    price DECIMAL(12, 4),
    volume BIGINT,
    amount DECIMAL(18, 4),
    trade_id VARCHAR(50)
);
```

#### 6. ETF æ•°æ®

**åŠŸèƒ½æè¿°**ï¼šETF è¡Œæƒ…ã€æŒä»“ã€å‡€å€¼ç­‰æ•°æ®

**ä»·å€¼**ï¼š
- ETF é€‰è‚¡
- è¡Œä¸šé…ç½®å‚è€ƒ
- å¥—åˆ©ç­–ç•¥

**æ•°æ®æ¥æº**ï¼šä¸œæ–¹è´¢å¯Œç½‘ ETF æ•°æ®

**æ•°æ®æ¨¡å‹è®¾è®¡**ï¼š

```python
class ETF(Base, TimestampMixin):
    """ETFæ•°æ®è¡¨"""
    __tablename__ = "etf_info"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    code: Mapped[str] = mapped_column(String(10))
    name: Mapped[str] = mapped_column(String(100))
    fund_type: Mapped[str] = mapped_column(String(50))  # åŸºé‡‘ç±»å‹
    tracking_index: Mapped[Optional[str]] = mapped_column(String(50))  # è·Ÿè¸ªæŒ‡æ•°
    fund_manager: Mapped[Optional[str]] = mapped_column(String(100))  # åŸºé‡‘ç»ç†
    establish_date: Mapped[Optional[date]] = mapped_column(Date)
    list_date: Mapped[Optional[date]] = mapped_column(Date)
    delisting_date: Mapped[Optional[date]] = mapped_column(Date)

    # è§„æ¨¡æ•°æ®
    fund_size: Mapped[Optional[float]] = mapped_column(Float)
    units: Mapped[Optional[BigInteger]] = mapped_column(BigInteger)

    # å®æ—¶æ•°æ®
    nav: Mapped[Optional[float]] = mapped_column(Float)  # å•ä½å‡€å€¼
    discount_premium: Mapped[Optional[float]] = mapped_column(Float)  # æŠ˜æº¢ä»·ç‡
    yield_1y: Mapped[Optional[float]] = mapped_column(Float)  # è¿‘ä¸€å¹´æ”¶ç›Šç‡
    yield_3y: Mapped[Optional[float]] = mapped_column(Float)  # è¿‘ä¸‰å¹´æ”¶ç›Šç‡
```

---

### ğŸŸ¢ ä½ä¼˜å…ˆçº§ï¼ˆå¯é€‰ï¼‰

#### 7. è‡ªåŠ¨åŒ–äº¤æ˜“æ¥å£

**åŠŸèƒ½æè¿°**ï¼š
- è‡ªåŠ¨ IPO ç”³è´­
- ç­–ç•¥è‡ªåŠ¨æ‰§è¡Œ
- æ¨¡æ‹Ÿç›˜/å®ç›˜åˆ‡æ¢

**æ³¨æ„äº‹é¡¹**ï¼š
- éœ€è¦åˆ¸å•†æ¥å£å¯¹æ¥
- é£é™©æ§åˆ¶è¦æ±‚é«˜
- å»ºè®®ä»…åšæ¨¡æ‹Ÿç›˜

#### 8. æ›´å¤šæŠ€æœ¯æŒ‡æ ‡

**å·²æœ‰æŒ‡æ ‡**ï¼š32ä¸ª

**å¯æ·»åŠ æŒ‡æ ‡**ï¼š
- Supertrendï¼ˆè¶…çº§è¶‹åŠ¿ï¼‰
- VHFï¼ˆå‚ç›´æ°´å¹³è¿‡æ»¤ï¼‰
- PPOï¼ˆä»·æ ¼éœ‡è¡ç‡ï¼‰
- DPOï¼ˆå»éœ‡è¡ï¼‰

---

## ğŸ› ï¸ å…·ä½“å®ç°æ–¹æ¡ˆ

### å®æ–½è·¯çº¿å›¾

#### ç¬¬ä¸€é˜¶æ®µï¼ˆ1-2å‘¨ï¼‰- é«˜ä¼˜å…ˆçº§åŠŸèƒ½

**ç›®æ ‡**ï¼š
1. å®ç°Kçº¿å½¢æ€è¯†åˆ«ï¼ˆ10ä¸ªåŸºç¡€å½¢æ€ï¼‰
2. æ·»åŠ é¾™è™æ¦œæ•°æ®åŒæ­¥

**ä»»åŠ¡æ¸…å•**ï¼š
- [ ] åˆ›å»ºæ•°æ®åº“è¡¨ç»“æ„
- [ ] å®ç°å½¢æ€è¯†åˆ«ç®—æ³•
- [ ] æ·»åŠ æ•°æ®åŒæ­¥æœåŠ¡
- [ ] åˆ›å»ºAPIç«¯ç‚¹
- [ ] å‰ç«¯å±•ç¤ºç»„ä»¶

#### ç¬¬äºŒé˜¶æ®µï¼ˆ2-3å‘¨ï¼‰- ä¸­ä¼˜å…ˆçº§åŠŸèƒ½

**ç›®æ ‡**ï¼š
3. å®ç°ç­¹ç åˆ†å¸ƒåˆ†æ
4. è·Œåœåˆ†æåŠŸèƒ½

**ä»»åŠ¡æ¸…å•**ï¼š
- [ ] åˆ›å»ºCYQæ•°æ®è¡¨
- [ ] å®ç°ç­¹ç è®¡ç®—é€»è¾‘
- [ ] åˆ›å»ºCYQå¯è§†åŒ–ç»„ä»¶
- [ ] è·Œåœæ•°æ®è·å–
- [ ] åŸå› åˆ†ç±»ç³»ç»Ÿ

#### ç¬¬ä¸‰é˜¶æ®µï¼ˆ3-4å‘¨ï¼‰- ä½ä¼˜å…ˆçº§åŠŸèƒ½

**ç›®æ ‡**ï¼š
5. ETF æ•°æ®æ”¯æŒ
6. å¤§å•èµ„é‡‘æµå‘ç»†åŒ–

---

## ğŸ“Š ä»·å€¼è¯„ä¼°çŸ©é˜µ

| åŠŸèƒ½ | æŠ€æœ¯éš¾åº¦ | å¼€å‘æ—¶é—´ | ç”¨æˆ·ä»·å€¼ | å•†ä¸šä»·å€¼ | ROI | æ¨èåº¦ |
|------|---------|---------|---------|---------|-----|--------|
| Kçº¿å½¢æ€è¯†åˆ« | ä¸­é«˜ | 1-2å‘¨ | â­â­â­â­â­ | â­â­â­â­â­ | é«˜ | â­â­â­â­â­ |
| ç­¹ç åˆ†å¸ƒåˆ†æ | ä¸­ | 1-2å‘¨ | â­â­â­â­â­ | â­â­â­â­â­ | é«˜ | â­â­â­â­â­ |
| é¾™è™æ¦œæ•°æ® | ä½ | 1å‘¨ | â­â­â­ | â­â­â­â­ | é«˜ | â­â­â­â­ |
| è·Œåœåˆ†æ | ä¸­ | 1-2å‘¨ | â­â­â­â­ | â­â­â­â­ | ä¸­ | â­â­â­ |
| å¤§å•èµ„é‡‘æµå‘ç»†åŒ– | ä½ | 3-5å¤© | â­â­â­â­ | â­â­â­ | ä¸­ | â­â­â­ |
| ETF æ•°æ® | ä½ | 3-5å¤© | â­â­â­â­ | â­â­â­ | ä¸­ | â­â­â­ |
| è‡ªåŠ¨åŒ–äº¤æ˜“æ¥å£ | é«˜ | 4-6å‘¨ | â­â­â­â­ | â­â­â­â­â­ | é«˜ | â­â­ |
| æ›´å¤šæŠ€æœ¯æŒ‡æ ‡ | ä½ | 1å‘¨ | â­â­â­ | â­â­â­ | ä¸­ | â­â­ |

---

## ğŸ’¡ æŠ€æœ¯äº®ç‚¹å€Ÿé‰´

### 1. æ€§èƒ½ä¼˜åŒ–

**InStock çš„ä¼˜åŒ–**ï¼š
- ä½¿ç”¨ TA-Lib C åº“æå‡è®¡ç®—æ€§èƒ½
- å¤šçº¿ç¨‹å¹¶å‘æ•°æ®è·å–
- æ‰¹é‡æ•°æ®åº“æ“ä½œ
- æ•°æ®é¢„è®¡ç®—å’Œç¼“å­˜

**SAPAS å¯å€Ÿé‰´**ï¼š
```python
# å°†å…³é”®è®¡ç®—æ”¹ä¸ºCæ‰©å±•
import talib

# æ‰¹é‡æ“ä½œä¼˜åŒ–
from sqlalchemy.dialects.postgresql import insert
batch_insert(stmt).returning(*stmt)
```

### 2. æ•°æ®è´¨é‡ä¿è¯

**InStock çš„åšæ³•**ï¼š
- å¤šæ•°æ®æºäº¤å‰éªŒè¯
- å¼‚å¸¸å€¼æ£€æµ‹
- æ•°æ®å®Œæ•´æ€§æ ¡éªŒ
- è‡ªåŠ¨é‡è¯•æœºåˆ¶

### 3. ç”¨æˆ·ä½“éªŒè®¾è®¡

**InStock çš„äº®ç‚¹**ï¼š
- çƒ­åŠ›å›¾å±•ç¤ºæ¿å—è¡¨ç°
- ä¸€é”®é€‰è‚¡åŠŸèƒ½
- ç­–ç•¥å¯¹æ¯”å±•ç¤º
- ç§»åŠ¨ç«¯é€‚é…

---

## ğŸ“ å®æ–½æ£€æŸ¥æ¸…å•

### Kçº¿å½¢æ€è¯†åˆ«å®æ–½æ£€æŸ¥æ¸…å•

- [ ] éœ€æ±‚åˆ†æå®Œæˆ
- [ ] æ•°æ®æ¨¡å‹è®¾è®¡å®Œæˆ
- [ ] API æ¥å£è®¾è®¡å®Œæˆ
- [ ] å‰ç«¯ç»„ä»¶è®¾è®¡å®Œæˆ
- [ ] æ•°æ®åŒæ­¥é€»è¾‘å®ç°
- [ ] å•å…ƒæµ‹è¯•å®Œæˆ
- [ ] é›†æˆæµ‹è¯•å®Œæˆ
- [ ] æ–‡æ¡£æ›´æ–°å®Œæˆ

### é¾™è™æ¦œæ•°æ®å®æ–½æ£€æŸ¥æ¸…å•

- [ ] éœ€æ±‚åˆ†æå®Œæˆ
- [ ] æ•°æ®æ¨¡å‹è®¾è®¡å®Œæˆ
- [ ] API æ¥å£è®¾è®¡å®Œæˆ
- [ ] æ•°æ®åŒæ­¥é€»è¾‘å®ç°
- [ ] æ•°æ®å±•ç¤ºé¡µé¢è®¾è®¡
- [ ] æµ‹è¯•å®Œæˆ

### ç­¹ç åˆ†å¸ƒåˆ†æå®æ–½æ£€æŸ¥æ¸…å•

- [ ] éœ€æ±‚åˆ†æå®Œæˆ
- [ ] ç®—æ³•é€»è¾‘éªŒè¯
- [ ] æ•°æ®æ¨¡å‹è®¾è®¡å®Œæˆ
- [ ] å¯è§†åŒ–ç»„ä»¶é€‰æ‹©
- [ ] æµ‹è¯•å®Œæˆ

---

## ğŸ”— å‚è€ƒèµ„æ–™

- **InStock ä»“åº“**: https://github.com/myhhub/stock
- **æŠ€æœ¯æ–‡æ¡£**: https://github.com/myhhub/stock/wiki
- **API æ–‡æ¡£**: https://github.com/myhhubstock/wiki/API
- **åŠŸèƒ½æ¼”ç¤º**: https://github.com/myhhubstock#åŠŸèƒ½æ¼”ç¤º

---

## ğŸ“Œ åè®°

æœ¬æ–‡æ¡£åŸºäº 2026-01-23 çš„åˆ†æç»“æœã€‚ä»£ç ä»“åº“å¯èƒ½æŒç»­æ›´æ–°ï¼Œå»ºè®®å®šæœŸæŸ¥çœ‹æœ€æ–°çš„åŠŸèƒ½å®ç°ã€‚

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**ï¼š
1. é€‰æ‹©1-2ä¸ªé«˜ä¼˜å…ˆçº§åŠŸèƒ½å¼€å§‹å®æ–½
2. ç¡®è®¤æŠ€æœ¯æ–¹æ¡ˆå’Œè®¾è®¡æ–‡æ¡£
3. åˆ›å»ºå¼€å‘ä»»åŠ¡å¹¶åˆ†é…
4. æŒ‰è·¯çº¿å›¾æ¨è¿›å®æ–½

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2026-01-23
**ä½œè€…**: SAPAS å›¢é˜Ÿ
**å®¡æ ¸äºº**: [å¾…å®š]

---

*æœ¬æ–‡æ¡£ä¸º SAPAS é¡¹ç›®çš„åŠŸèƒ½è§„åˆ’æä¾›å‚è€ƒï¼Œå…·ä½“å®æ–½æ—¶éœ€æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´*